// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract EntityRegistry {
    address public owner;

    enum EntityType { NONE, UNIVERSITY, EMPLOYER, STUDENT }

    struct EntityInfo {
        string entityId_on_KAMC_Chain; // Unique ID generated by this contract
        EntityType entityType;
        string name;
        address primaryAddress_on_KAMC_Chain; // Address that registered this entity
        address specificChainAddress; // e.g., Uni address on UNI-Chain, Emp address on EMP-Chain
        string metadata; // e.g., JSON string for additional info
        bool isActive;
    }

    uint256 private nextEntityNumericId;
    mapping(string => EntityInfo) public entitiesById;
    mapping(address => string) public entityIdByPrimaryAddress; // KAMC chain primary address to KAMC ID

    event EntityRegistered(
        string indexed entityId_on_KAMC_Chain,
        EntityType indexed entityType,
        string name,
        address primaryAddress_on_KAMC_Chain,
        address specificChainAddress
    );

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function.");
        _;
    }

    constructor() {
        owner = msg.sender;
        nextEntityNumericId = 1;
    }

    function _generateEntityId(EntityType _type) private returns (string memory) {
        string memory prefix;
        if (_type == EntityType.UNIVERSITY) {
            prefix = "UNI-";
        } else if (_type == EntityType.EMPLOYER) {
            prefix = "EMP-";
        } else if (_type == EntityType.STUDENT) {
            prefix = "STU-";
        } else {
            revert("Invalid entity type for ID generation");
        }
        string memory newId = string(abi.encodePacked(prefix, uintToString(nextEntityNumericId)));
        nextEntityNumericId++;
        return newId;
    }

    function registerUniversity(
        string calldata _uniName,
        address _uniAddress_on_UNI_Chain,
        string calldata _metadata
    ) external returns (string memory entityId) {
        require(bytes(entityIdByPrimaryAddress[msg.sender]).length == 0, "Address already registered an entity.");
        
        entityId = _generateEntityId(EntityType.UNIVERSITY);
        entitiesById[entityId] = EntityInfo(
            entityId,
            EntityType.UNIVERSITY,
            _uniName,
            msg.sender, // primaryAddress_on_KAMC_Chain
            _uniAddress_on_UNI_Chain,
            _metadata,
            true
        );
        entityIdByPrimaryAddress[msg.sender] = entityId;

        emit EntityRegistered(entityId, EntityType.UNIVERSITY, _uniName, msg.sender, _uniAddress_on_UNI_Chain);
        return entityId;
    }

    function registerEmployer(
        string calldata _empName,
        address _empAddress_on_EMP_Chain,
        string calldata _metadata
    ) external returns (string memory entityId) {
        require(bytes(entityIdByPrimaryAddress[msg.sender]).length == 0, "Address already registered an entity.");

        entityId = _generateEntityId(EntityType.EMPLOYER);
        entitiesById[entityId] = EntityInfo(
            entityId,
            EntityType.EMPLOYER,
            _empName,
            msg.sender, // primaryAddress_on_KAMC_Chain
            _empAddress_on_EMP_Chain,
            _metadata,
            true
        );
        entityIdByPrimaryAddress[msg.sender] = entityId;

        emit EntityRegistered(entityId, EntityType.EMPLOYER, _empName, msg.sender, _empAddress_on_EMP_Chain);
        return entityId;
    }

    function registerStudent(
        string calldata _studentName,
        string calldata _metadata
    ) external returns (string memory entityId) {
        require(bytes(entityIdByPrimaryAddress[msg.sender]).length == 0, "Address already registered an entity.");

        entityId = _generateEntityId(EntityType.STUDENT);
        entitiesById[entityId] = EntityInfo(
            entityId,
            EntityType.STUDENT,
            _studentName,
            msg.sender, // primaryAddress_on_KAMC_Chain
            address(0), // Students might not have a specific chain address initially, or it can be updated
            _metadata,
            true
        );
        entityIdByPrimaryAddress[msg.sender] = entityId;

        emit EntityRegistered(entityId, EntityType.STUDENT, _studentName, msg.sender, address(0));
        return entityId;
    }

    function getEntityInfo(string calldata _entityId) external view returns (EntityInfo memory) {
        require(entitiesById[_entityId].isActive, "Entity not found or inactive.");
        return entitiesById[_entityId];
    }
    
    function getEntityIdByPrimaryAddress(address _primaryAddress) external view returns (string memory) {
        return entityIdByPrimaryAddress[_primaryAddress];
    }

    function updateEntitySpecificChainAddress(string calldata _entityId, address _newSpecificChainAddress) external {
        require(entitiesById[_entityId].isActive, "Entity not found or inactive.");
        require(entitiesById[_entityId].primaryAddress_on_KAMC_Chain == msg.sender, "Only entity owner can update.");
        entitiesById[_entityId].specificChainAddress = _newSpecificChainAddress;
    }

    function deactivateEntity(string calldata _entityId) external onlyOwner { // Or by entity owner
        require(entitiesById[_entityId].isActive, "Entity not found or already inactive.");
        entitiesById[_entityId].isActive = false;
        // Consider emitting an event
    }

    // Helper to convert uint to string (needed for ID generation)
    function uintToString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}
